import argparse
import json
import logging
import os
from pathlib import Path

import torch
from langchain.output_parsers import PydanticOutputParser
from PIL import Image

from layoutlib.hfds import hfds_helper_factory, sample_example
from layoutlib.hfds.clustering import clustering_default_weight_path_factory
from layoutlib.hfds.util import extract_class_label_mappings
from layoutlib.manager import LayoutManager
from layoutlib.schema import get_layout_pydantic_model
from opencole.inference.tester.llm import TypographyLMMTester
from opencole.schema import Detail, DetailV1

logging.basicConfig(level=os.environ.get("LOGLEVEL", "INFO"))
logger = logging.getLogger(__name__)

torch.set_default_dtype(torch.float16)


def main(DetailClass: type[Detail]) -> None:
    parser = argparse.ArgumentParser()
    TypographyLMMTester.register_args(parser)

    parser.add_argument(
        "--preprocess_args",
        type=str,
        default="src/opencole/inference/typographylmm_config/crello_default.json",
        help="path to the preprocess_args.json file produced by opencole.preprocess.create_dataset_for_typographylmm",
    )
    # I/O
    parser.add_argument(
        "--detail_dir",
        type=str,
        required=True,
        help="directory containing a generated design plan given an intention.",
    )
    parser.add_argument(
        "--image_dir",
        type=str,
        required=True,
        help="directory containing a single image generated by text-to-image given a detail.",
    )
    parser.add_argument("--output_dir", type=str, required=True)
    parser.add_argument("--first_n", type=int, default=None)
    # llava model
    parser.add_argument(
        "--pretrained_model_name_or_path",
        type=str,
        required=True,
    )
    parser.add_argument("--load_in_4bit", action="store_true")
    parser.add_argument("--load_in_8bit", action="store_true")
    parser.set_defaults(max_new_tokens=2048)
    args = parser.parse_args()
    logger.info(f"{args=}")

    with open(args.preprocess_args, "r") as fp:
        preprocess_args = json.load(fp)

    output_dir = Path(args.output_dir)
    if not output_dir.exists():
        output_dir.mkdir(parents=True, exist_ok=True)

    _, features = sample_example(preprocess_args["hfds_name"])
    class_label_mappings = extract_class_label_mappings(features)
    layout_manager = LayoutManager(
        schema_name=preprocess_args["schema_name"],
        weight_path=clustering_default_weight_path_factory(
            preprocess_args["hfds_name"]
        ),
        class_label_mappings=class_label_mappings,
    )
    layout_parser = PydanticOutputParser(  # type: ignore
        pydantic_object=get_layout_pydantic_model(
            schema=layout_manager.schema,
            class_label_mappings=layout_manager.class_label_mappings,
            skip_showing_choices=preprocess_args["skip_showing_choices"],
        )  # type: ignore
    )
    hfds_helper = hfds_helper_factory(
        hfds_name=preprocess_args["hfds_name"], features=features
    )

    tester_kwargs = {
        k: v
        for k, v in vars(args).items()
        if k
        not in ["detail_dir", "image_dir", "output_dir", "preprocess_args", "first_n"]
    }
    tester = TypographyLMMTester(
        layout_parser=layout_parser,
        layout_manager=layout_manager,
        hfds_helper=hfds_helper,
        **tester_kwargs,
    )

    details = list(Path(args.detail_dir).glob("*.json"))
    images = list(Path(args.image_dir).glob("*.png"))
    assert len(details) == len(images) and len(details) > 0
    assert set([x.stem for x in details]) == set([x.stem for x in images])
    detail_image_pairs = [(x, y) for x, y in zip(sorted(details), sorted(images))]
    if tester.use_chunking:
        detail_image_pairs = tester.get_chunk(detail_image_pairs)

    if args.first_n is not None:
        detail_image_pairs = detail_image_pairs[: args.first_n]

    for detail_path, image_path in detail_image_pairs:
        image = Image.open(str(image_path))
        try:
            with detail_path.open("r") as fp:
                detail = DetailClass(**json.load(fp))
        except UnicodeDecodeError:
            from IPython import embed

            embed()
            exit()

        output_path = output_dir / f"{detail_path.stem}.json"
        if output_path.exists():
            logger.info(f"Skipping {detail_path.stem} since it already exists.")
            continue

        output = tester(image, detail)
        if output is None:
            with output_path.open("w") as fp:
                json.dump({}, fp, indent=4)
        else:
            with output_path.open("w") as fp:
                json.dump(output, fp, indent=4)


if __name__ == "__main__":
    main(DetailClass=DetailV1)
